# day1

## python的输入输出

### 1.输出

python的输出函数为print()，它可以在控制台打印括号里输入的内容。

当括号里有多个数据要输出时，每个数据之间要用英文的逗号隔开

```python
print(数据1, 数据2, 数据3, ..., sep=' ', end='\n')
```

sep关键字：用来定义多个数据之间的分隔符，默认为空格

end关键字：用来定义数据输出完之后用什么字符结束，默认为换行符（\n）

### 2.输入

python中的输入函数为input函数，它是一个阻塞函数，当该函数执行时程序会停下来，等待用户输入相应的文字，然后返回用户输入文字的**字符串**

```python
# input("提示信息")
name = input("请输入你的名字")
#请注意input函数的参数是字符串，因此nmae变量是一个字符串类型
```



## python的注释

python中，注释并不会影响程序的执行，注释只是为了增添代码的可读性。

python中注释分为**单行注释和多行注释**

### 1.井号（#）

```python
# 这是一段注释
```

### 2.单引号（''' '''）

```python
'''
这里是一个单引号的多行注释
12345678
'''
```

### 3.双引号（""" """）

```python
"""
这里是双引号的多行注释
123456

"""
```



## python的变量

### 1.赋值语句

```python
"""
变量名 = 数字类型
变量名 = 表达式
变量名1 = 变量名2 = 变量名3  = 数字类型
变量名1, 变量名2, 变量名3  = 数字类型1, 数字类型2, 数字类型3
"""

num = 1
num1 = num2 = num3 = 4
num1 ,num2 ,num3 = 1 ,2 ,3
name = "qwefg"
fl = 3.14
```

赋值语句的是一个从右往左的运算，意思是将右边的值赋值给左边的变量。

变量本身是没有类型的，右边的值赋值给变量之后同时也将右边的值的类型给了变量

### 2.变量

变量名：必须是一个标识符

标识符的命名规则：

1.第一个字母必须是英文字母或者下划线，**不能以数字开头**

2.从第二个字母开始必须是英文字母、下划线、数字

3.python中变量名区分大小写

```
#以下都是一些合法的标识符
a        a1           abc       ABC     a1b2c3d4
one_hundred          count      _a      __ABC__

getNameAge         get_name_age        GetNameAge
# 小驼峰              匈牙利命名法         大驼峰
ps：python中关键字不能作为标识符
```

推荐使用的命名方式

- 变量名全部采用小写字母，如pythonstring
- 简短、有意义，如pystr
- 多个单词间用下划线分隔，如py_str
- 变量名用名词，函数名用谓词（动词+名词），如 phone / update_phone
- 类名采用驼峰形式，如MyClass

关键字：

计算机编程语言中保留的标识符称为关键字, **关键字不能当成变量名使用**



python中的部分常见关键字

```python
False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield
```

## python的数据类型

python中的数据类型大致分为两类，一种是**基础类型**另外一种是**引用类型**

其中基础类型包括：

1.字符串str

2.数字

整数int

浮点数float

布尔数bool

引用类型包括：

1.列表list：可变序列，用于存储一组值，可以包含不同类型的元素。

2.元组tuple：不可变序列，用于存储一组值，元素不能被修改。

3.字典dict：键值对映射，用于存储关联性数据，由键和对应的值组成。

4.集合set：无序集合，用于存储唯一的元素，不允许重复。

5.字节串bytes/字节数组bytearray

6.枚举类型（Enum）：本质上是一个类，它是标准库中的`enum`模块提供的一个功能，用于创建有限的、命名的枚举类型

7.自定义类（class）：创建自定义类来表示复杂的数据结构，具有自定义属性和方法。

### 1.字符串

```python
print('你好')
print("你好")
print('''你好''')
print("""你好""")
```

字符串的转义

```
\'    代表一个单引号
\"    代表一个双引号
\n    代表一个换行符
\\    代表一个反斜杠
```

| 转义序列   | 含义                       | 注释  |
| ---------- | -------------------------- | ----- |
| `\newline` | 反斜杠加换行全被忽略       |       |
| `\\`       | 反斜杠 (`\`)               |       |
| `\'`       | 单引号 (`'`)               |       |
| `\"`       | 双引号 (`"`)               |       |
| `\a`       | ASCII 响铃 (BEL)           |       |
| `\b`       | ASCII 退格 (BS)            |       |
| `\f`       | ASCII 进纸 (FF)            |       |
| `\n`       | ASCII 换行 (LF)            |       |
| `\r`       | ASCII 回车 (CR)            |       |
| `\t`       | ASCII 水平制表 (TAB)       |       |
| `\v`       | ASCII 垂直制表 (VT)        |       |
| `\ooo`     | 八进制数 *ooo* 码位的字符  | (1,3) |
| `\xhh`     | 十六进制数 *hh* 码位的字符 | (2,3) |

#### 2.字符串的运算

1.字符串的连接：+

+号运算符，用于拼接字符串（生成新的字符串）

注意：+号两侧都必须是字符串

2.字符串多次重复：*运算，用于生成重复的字符串

3.in/not in 运算

in 用于序列，字符串，字典中，用于判断某个值是否存在于序列中,如果存在就返回True, 否则返回False

not in 的返回值与 in 相反

#### 3.字符串的访问

##### 3.1一般访问

语法：

```
字符串[索引]
```

作用：

用来获取字符串其中的一个字符



正向索引: 字符串的正向索引是从0开始的，.... 最后一个索引为 len(s)-1

反向索引: 字符串的反向索引是从 -1 开始的，-1 代表最后一个，... -len(s) 代表第一个

##### 3.2字符串的切片访问

```
字符串[(开始索引b):(结束索引e)(:(步长s))]
```

说明：

- 开始索引b是切片切下的开始位置

- 结束索引e 是切片的终止位置**(但不包含终止点)**
- 步长是切片取出数据后向后移动的方向和偏移量
  - 没有步长，相当于步长为1(默认为1)
  - 当步长为正数时，取正向切片
    - 开始索引默认为0, 结束索引是最后一个元素的下一个索引
  - 当步长为负数时，取反向切片
    - 开始索引默认为-1, 结束索引是第一个元素的前一个索引

##### 3.3字符串的格式化表达式

##### 3.4字符串的常用函数api

方法调用的语法

```
对象.方法名(参数)
```

| 1    | **capitalize**()将字符串的第一个字符转换为大写               |
| ---- | ------------------------------------------------------------ |
| 2    | **count**(str, beg= 0,end=len(string))返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 |
| 3    | **find**(str, beg=0, end=len(string))检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 |
| 4    | **join**(seq)以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 |
| 5    | **split**(sep="", maxsplit=string.count(str))以 sep为分隔符截取字符串，如果 maxsplit有指定值，则仅截取 maxsplit+1 个子字符串 |
| 6    | **strip**(chars)在字符串上执行 lstrip()和 rstrip()           |
| 7    | **startswith**(substr, beg=0,end=len(string))检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 |
| 8    | **upper**()转换字符串中的小写字母为大写                      |
| 9    | **lower**()转换字符串中所有大写字符为小写.                   |
| 10   | **isdigit**()如果字符串只包含数字则返回 True 否则返回 False  |

### 2.数字

Python 中的基本的数字类型

- 整数 int
- 浮点数(小数)  float
- 布尔类型数 bool

### 3.del删除变量

可以通过使用del语句删除单个或多个对象的引用

```
x=100
del x
print(x)#报错name 'x' is not defined
```

# day2

## python数字操作

### 1.类型转换

int(x)：将x转换成整数

float(x)：将x转换成浮点数

bin(x)：将x转换成二进制

oct(x)：将x转换成八进制

hex(x)：将x转换成十六进制

complex(x，y)：将x和y转换成一个复数，实数部分为x，虚数部分为y

bool(x)：将x转换成布尔值

### 2.运算符

#### 算术运算符

+：加法

-：减法

*：乘法

/：除法

%：取余数

**：幂运算（求次方）

//：整除

pass：除法最后结果总是一个浮点数，不同类型的数混合运算的时候整数会转换成浮点数

#### 比较运算符

- `==`：等于
- `!=`：不等于
- `<`：小于
- `>`：大于
- `<=`：小于等于
- `>=`：大于等于

以上运算符的运算结果为布尔值

#### 逻辑运算符

- `and`：与（逻辑与）
- `or`：或（逻辑或）
- `not`：非（逻辑非）

and运算符全真才为真，有一个假便为假

or运算符全假才为假，有一个真便为真

not运算符即真变假，假变真

#### 位运算符

- `&`：按位与
- `|`：按位或
- `^`：按位异或
- `~`：按位取反
- `<<`：左移位
- `>>`：右移位

按位与：全1为1，全0为0，不同为0

```
# 示例：计算两个二进制数的按位与
a = 0b1011  # 二进制表示的11
b = 0b1101  # 二进制表示的13
result_and = a & b  # 计算两者之间的按位与
print(bin(result_and))  # 输出：0b1001 （十进制为9）
```

按位或：不同为1，全0为0，全1为1

```
# 示例：计算两个二进制数的按位或
a = 0b1011
b = 0b1101
result_or = a | b  # 计算两者之间的按位或
print(bin(result_or))  # 输出：0b1111 （十进制为15）
```

按位异或：相同为0，不同为1

```
# 示例：计算两个二进制数的按位异或
a = 0b1011
b = 0b1101
result_xor = a ^ b  # 计算两者之间的按位异或
print(bin(result_xor))  # 输出：0b110 （十进制为6）
```

按位取反：1变0，0变1

```
# 示例：计算一个二进制数的按位取反
a = 0b1011
result_not = ~a  # 计算a的按位取反
print(bin(result_not))  # 输出：-0b1100
```

左移运算符：

```
# 示例：将一个二进制数向左移动两位
a = 0b1011
result_left_shift = a << 2  # 将a向左移动两位，相当于a的十进制数乘以2的2次方
print(bin(result_left_shift))  # 输出：0b101100 （十进制为44）
```

右移运算符：

```
# 示例：将一个有符号二进制数向右移动一位
a = -0b1000  # 十进制为-8
result_right_shift = a >> 1  # 将a向右移动一位，相当于a的十进制数除以2的1次方
print(bin(result_right_shift))  # 输出：-0b100 （十进制为-4）

# 对于无符号数的例子
unsigned_a = 0b1000
unsigned_result_right_shift = unsigned_a >> 1
print(bin(unsigned_result_right_shift))  # 输出：0b100 （十进制为4）
```



#### 赋值运算符

- `=`：赋值

- `+=`：加法赋值

- `-=`：减法赋值

- `*=`：乘法赋值

- `/=`：除法赋值

- `%=`：取余赋值

- `**=`：幂运算赋值

- `//=`：整除赋值

## 条件语句

Python中if语句的一般形式如下所示：

```
if condition_1:
    statement_block_1
elif condition_2:
    statement_block_2
else:
    statement_block_3
```

- 如果 "condition_1" 为 True 将执行 "statement_block_1" 块语句
- 如果 "condition_1" 为False，将判断 "condition_2"
- 如果"condition_2" 为 True 将执行 "statement_block_2" 块语句
- 如果 "condition_2" 为False，将执行"statement_block_3"块语句

注意：

1、每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。

2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。





在嵌套 if 语句中，可以把 if...elif...else 结构放在另外一个 if...elif...else 结构中

```
if 表达式1:
    语句
    if 表达式2:
        语句
    elif 表达式3:
        语句
    else:
        语句
elif 表达式4:
    语句
else:
    语句
```

## 循环语句

Python 中的循环语句有 for 和 while。

### while循环

Python 中 while 语句的一般形式：

```
while 判断条件(condition)：
    执行语句(statements)……
```

### for循环

Python for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串。

for循环的一般格式如下：

```
for <variable> in <sequence>:
    <statements>
else:
    <statements>
```

for循环经常搭配**range函数**来使用

## break 和 continue 语句

**break** 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。

**continue** 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。

### pass语句

Python中pass是空语句，是为了保持程序结构的完整性。

pass 不做任何事情，一般用做占位语句

## 容器

### 列表

列表中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。

列表的数据项不需要具有相同的类型

创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：

```
list1 = ['abc', '1234', 1997, 2000]
list2 = [1, 2, 3, 4, 5 ]
```

#### 访问列表中的值

与字符串的索引一样，列表索引从 0 开始，第二个索引是 1，依此类推。

索引也可以从尾部开始，最后一个元素的索引为 -1，往前一位为 -2，以此类推。

列表的切片访问与字符串类似

列表是可变的容器(不同于字符串)

#### 列表的增删改查

##### 增加

| 方法名(L代表列表)    | 说明                                             |
| -------------------- | ------------------------------------------------ |
| L.append(x)          | 向列表的末尾追加单个数据                         |
| L.insert(index, obj) | 将某个数据obj 插入到 index这个索引位置的数据之前 |
| L.extend(可迭代对象) | 等同于: L += 可迭代对象                          |

##### 删除

| 方法        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| L.remove(x) | 从列表L中删除第一次出现在列表中的数据元素，如果x不存在则报错 |
| L.clear()   | 清空列表                                                     |

##### 修改

修改数据

- 用索引赋值可以改变列表内的数据

```python
列表[整数表达式] = 表达式
```

##### 查找

查看(索引取值就是查看)

```
print(L[0])  # 取值
```

#### 列表常用api

函数：

| 1    | **len(list)列表元素个数**       |
| ---- | ------------------------------- |
| 2    | **max()list返回列表元素最大值** |
| 3    | **min(list)返回列表元素最小值** |
| 4    | **list(seq)将元组转换为列表**   |

方法：

| 1    | s.append(x)在列表末尾添加新的对象                            |
| ---- | ------------------------------------------------------------ |
| 2    | **s.count(x)统计某个元素在列表中出现的次数**                 |
| 3    | **s.extend(t)在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）** |
| 4    | **s.index()从列表中找出某个值第一个匹配项的索引位置**        |
| 5    | **s.insert(i, x)将对象插入列表**                             |
| 6    | **s.pop([i]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值** |
| 7    | **s.remove(x)移除列表中某个值的第一个匹配项**                |
| 8    | **s.reverse()反向列表中元素**                                |
| 9    | **s.sort( key=None, *reverse=False*)对原列表进行排序**       |
| 10   | **s.clear()清空列表**                                        |
| 11   | **`s.copy()`复制列表**                                       |

### 元组

- 元组是不可改变的列表
- 同列表list 一样，元组可以存放任意类型的数据
- 但是，一旦创建将不可修改
- 元组使用小括号 ( )，列表使用方括号 [ ]

```
tup1 = (1, 2, 3, 4, 5 )
```

元组中只包含一个元素时，需要在元素后面添加逗号 ,否则括号会被当作运算符使用

元组与字符串类似，下标索引从 0 开始，可以进行截取，组合等

元组可以使用下标索引来访问元组中的值

##### 元组常用API

Python元组包含了以下内置函数

| 序号 | 方法        | 描述                   |
| ---- | ----------- | ---------------------- |
| 1    | len(tuple)  | 返回元组中元素个数。   |
| 2    | max(tuple)  | 返回元组中元素最大值。 |
| 3    | min(tuple)  | 返回元组中元素最小值。 |
| 4    | tuple(list) | 将列表转换为元组。     |

元组常用的方法

| 运算                 | 结果                                                         |
| :------------------- | :----------------------------------------------------------- |
| s.index(x[, i[, j]]) | *x* 在 *s* 中首次出现项的索引号（索引号在 *i* 或其后且在 *j* 之前） |
| s.count(x)           | *x* 在 *s* 中出现的总次数                                    |

### 字典

字典是另一种可变容器模型，且可存储任意类型对象。

字典的每个键值 key=>value  对用冒号 :  分割，每个对之间用逗号(**,**)分割，整个字典包括在花括号 {} 中 ,格式如下所示：

```
d = {key1 : value1, key2 : value2, key3 : value3 }
```

键必须是唯一的，但值则不必。

值可以取任何数据类型，但键必须是不可变的，如字符串，数字。

##### 字典常用API

操作字典的函数：

| 序号 | 函数           | 描述                                               |
| ---- | -------------- | -------------------------------------------------- |
| 1    | len(dict)      | 计算字典元素个数，即键的总数。                     |
| 2    | str(dict)      | 输出字典，可以打印的字符串表示。                   |
| 3    | type(variable) | 返回输入的变量类型，如果变量是字典就返回字典类型。 |

字典的方法：

| 序号 | 函数及描述                                                   |
| ---- | ------------------------------------------------------------ |
| 1    | dict.clear()删除字典内所有元素                               |
| 2    | dict.copy()返回一个字典的浅复制                              |
| 3    | dict.fromkeys(seq)创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 |
| 4    | dict.get(key, default=None)返回指定键的值，如果键不在字典中返回 default 设置的默认值 |
| 5    | key in dict如果键在字典dict里返回true，否则返回false         |
| 6    | dict.items()以列表返回一个视图对象                           |
| 7    | dict.keys()返回一个视图对象                                  |
| 8    | dict.setdefault(key, default=None)和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |
| 9    | dict.update(dict2)把字典dict2的键/值对更新到dict里           |
| 10   | dict.values()返回一个视图对象                                |
| 11   | pop(key,default)删除字典 key（键）所对应的值，返回被删除的值。 |
| 12   | popitem()返回并删除字典中的最后一对键和值。                  |

### 集合

集合（set）是一个无序的不重复元素序列。

集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作。

可以使用大括号 { } 创建集合，元素之间用逗号 , 分隔， 或者也可以使用 set() 函数创建集合。

##### 集合常用API

集合的方法

| 方法                          | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| add()                         | 为集合添加元素                                               |
| clear()                       | 移除集合中的所有元素                                         |
| copy()                        | 拷贝一个集合                                                 |
| difference()                  | 返回多个集合的差集                                           |
| difference_update()           | 移除集合中的元素，该元素在指定的集合也存在。                 |
| discard()                     | 删除集合中指定的元素                                         |
| intersection()                | 返回集合的交集                                               |
| intersection_update()         | 返回集合的交集。                                             |
| isdisjoint()                  | 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 |
| issubset()                    | 判断指定集合是否为该方法参数集合的子集。                     |
| issuperset()                  | 判断该方法的参数集合是否为指定集合的子集                     |
| pop()                         | 随机移除元素                                                 |
| remove()                      | 移除指定元素                                                 |
| symmetric_difference()        | 返回两个集合中不重复的元素集合。                             |
| symmetric_difference_update() | 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。 |
| union()                       | 返回两个集合的并集                                           |
| update()                      | 给集合添加元素                                               |
| len()                         | 计算集合元素个数                                             |

# day3

## 推导式

### 列表推导式

```python
[ 表达式 for 自定义变量 in 可迭代对象 ]
# 或
[ 表达式 for 自定义变量 in 可迭代对象 if 真值表达式 ]

l = [i for i in range(10)]

上面表达式等同于

l = []
for i in range(10):
    l.append(i)
```



### 字典推导式

字典推导基本格式：

- **{ 键表达式: 值表达式 for 元素 in 集合 }**

- **{ 键表达式: 值表达式 for 元素 in 集合 if 条件 }**

```python
dic = {x: x**2 for x in (2, 4, 6)}
```

### 集合推导式

集合推导式基本格式：

- **{ 表达式 for 元素 in 序列 }**
- **{ 表达式 for 元素 in 序列 if 条件 }**

```python
setnew = {i**2 for i in (1,2,3)}
```

### 元组推导式

元组推导式基本格式：

- **（表达式 for 元素 in 序列 ）**
- **（表达式 for 元素 in 序列 if 条件 ）**

```
#生成一个包含数字 1~9 的元组
a = (x for x in range(1,10))
```

## 函数

函数是可以重复执行的语句块，可以重复调用

函数的作用是：用于封装语句块, 提高代码的复用性。

### def语句

作用：用来定义函数

语法：

```python
def 函数名(形式参数列表):
	语句块
```

说明：

1、函数必须以def开头，函数名后必须接圆括号，圆括号后必须接冒号

2、函数的参数位置可以为空也可以不为空

3、函数外部不能访问函数内部的变量，但是在函数内部可以访问函数外部的变量，但是不能轻易改变它的值

4、return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回None

```python
# 定义一个函数，用 say_hello 变量绑定
def say_hello():
	print("hello world!")
	print("hello tarena!")
	print("hello everyone!")
# 定义一个函数，传入两个参数，让这个函数把最大的值打印到终端
def mymax(a, b):
	if a > b:
		print("最大值是", a)
	else:
		print("最大值是", b)
```

### 函数的调用

语法：

```
函数名(实际调用传递参数)
```

说明：

1、函数调用是一个表达式
2、如果函数内没有return 语句，函数执行完毕后返回 None 对象

### return语句

语法：

```python
return [表达式]#表示可以省略
```

作用：用于函数的内部，结束当前函数的执行，返回到调用此函数的地方，同时返回一个对象的引用关系

说明：

1、return 语句后面的表达式可以省略，省略后相当于 return None

2、如果函数内部没有 return 语句, 则函数执行完毕后返回None, 相当于在最后一条语句后有一条return None



### 函数的参数

#### 函数的调用传参

1、位置传参

实际参数传递时，实参和形参按位置来依次对应

2、关键字传参

实际参数传递时，实参和形参按名称依次对应

注意：位置参数要先于关键字参数

```python
def myfun1(a, b, c):
print('a=', a)
print('b=', b)
print('c=', c)
## 位置传参
myfun1(1, 2, 3)
## 关键字传参
myfun1(c=33, a=11, b=22)
## 位置传参要先于关键字传参
myfun1(111, c=333, b=222)
```

#### 函数的形式参数定义方法

##### 函数的默认参数

语法：

```python
def 函数名(形参名1=默认实参1, 形参名2=默认实参2, ... ):
语句块
```

说明：

默认实参即缺省参数，必须自右向左依次存在(即,如果一个参数有缺省参数，则其右侧的所有参数都必须有缺省参数

```python
def myadd4(a, b, c=0, d=0):
    print(a)
    print(b)
    print(c)
    print(d)
    return a + b + c + d
print(myadd4(1, 2))
print(myadd4(1, 2, 3))
print(myadd4(1, 2, 3, 4))
```

#### 形参的定义

形参分为四种：

1、位置形参
2、星号元组形参(*args)
3、命名关键字形参
4、双星号字典形参（**kwargs）

##### 位置形参

语法：

```python
def 函数名(形参名1, 形参名2, ...):
	pass
```



##### 星号形参

语法：

```python
def 函数名(*元组形参名):
	pass
```

作用：收集多余的位置实参，一般命名为args



##### 命名关键字形参

语法：

```python
def 函数名(*, 命名关键字形参1, 命名关键字形参2, ...):
	pass
# 或者
def 函数名(*args, 命名关键字形参1, 命名关键字形参2, ...):
	pass
```

作用：强制，所有的参数都必须用关键字传参

##### 双星号形参

语法：

```python
def 函数名(**字典形参名):
	pass
```

作用：收集多余的关键字传参

字典形参名最多只有一个，一般命名为kwargs





函数的形参定义方法说明：
位置形参，星号元组形参，命名关键字参数，双星号字典形参，缺省参数可以混合使用。
函数的形参定义自左至右的顺序为：位置形参，星号元组形参，命名关键字参数，双星号字典形参

### 匿名函数

在Python中，匿名函数通常使用 lambda 关键字来创建。匿名函数也被称为lambda函数，它是一种简单的、一行的函数，常用于临时需要一个小函数的地方。匿名函数的语法如下：

```python
lambda [函数的参数列表]: 表达式
```

作用：

1、创建一个匿名函数对象
2、lambda 是关键字，表示你正在定义一个匿名函数。

3、同 def 类似，但不提供函数名

4、[函数的参数列表] 是函数的参数，可以有零个或多个参数，参数之间用逗号分隔。
5、: 表达式 是函数的返回值，通常是一个表达式，匿名函数会计算这个表达式并返回结果。



说明：

lambda 表达式 的创建函数只能包含一个表达式

```python
myadd2 = lambda x, y: x + y
print('3 + 4 =', myadd2(3, 4)) 
```

### 变量作用域

#### 局部变量

定义在函数内部的变量称为局部变量(函数的形参也是局部变量)

函数内部的变量只能在函数内部或者函数内部的函数内部访问 ，函数外部不能访问

局部变量在函数调用时才能够被创建，在函数调用之后会自动销毁

#### 全局变量

定义在函数外部，模块内部的变量称为全局变量

全局变量, 所有的函数都可以直接访问(取值,但函数内部不能直接将其赋值改变)

#### 局部作用域修改全局变量

```python
global 变量名1, 变量名2, ....
```

global 说明：
1、全局变量如果要在函数内部被赋值，则必须经过全局声明 global
2、默认全局变量在函数内部可以使用，但只能取值，不能赋值
3、不能先声明为局部变量，再用 global 声明为全局变量，此做法不符合语法规则
函数的形参已经是局部变量，不能用 global 声明为全局变量

#### 局部作用域修改外部变量

在函数内部 提前用nonlocal声明 函数内部的某个变量为外部的变量

前提：必须是函数嵌套

#### 函数自调用（递归）

函数直接或间接的调用自身

递归一定要控制递归的层数，当符合某一条件时要终止递归调用

# day4

## 面向对象编程

在理解面向对象编程之前，我们要明确什么是面向过程编程。

下面我将用一个示例来大概得区分面向过程编程和面向对象编程。（将大象放进冰箱里），这个事情以面向过程编程的思想来看可以分为三步，第一步打开冰箱门，第二步把大象放进去，第三步关闭冰箱门。而以面向对象编程的思想来看，可以把这个事情分成两个对象，一个是冰箱，一个是大象，冰箱又分为两个行为（打开和关闭），大象有一个行为是进冰箱。该示例大概区别了面向对象和面向过程。

1、什么是对象
对象是指现实中的物体或实体
2、什么是面向对象
把一切看成对象（实例），用各种对象之间的关系来描述事务。
3、对象都有什么特征
对象有很多属性(名词)
姓名, 年龄, 性别,
对象有很多行为(动作,动词)
学习,吃饭,睡觉,踢球, 工作
4、什么是类：
拥有相同属性和行为的对象分为一组,即为一个类
类是用来描述对象的工具,用类可以创建此类的对象(实例)

### 类和对象的基础语法

#### 类的定义

类是创建对象的模板

数据成员：表明事务的特征，相当于变量

方法成员：表明事务的功能，相当于函数

通过class关键字定义类

语法：

```python
class 类名 (继承列表):
	实例方法(类内的函数method) 定义
	类变量(class variable) 定义
	类方法(@classmethod) 定义
	静态方法(@staticmethod) 定义
```

类的创建的说明:
类名必须为标识符(与变量的命名相同,建议首字母大写)
类名实质上就是变量，它绑定一个类

#### 实例化对象（构造函数）

1、构造函数调用表达式

```python
变量 = 类名(参数)
```

2、说明

1、变量存储的是实例化后的对象地址

2、类名后面的参数按照构造方法的形参传递

3、对象是类的实例，具有类定义的属性和方法

4、通过调用类的构造函数来创建对象

5、每个对象都有自己的状态，但共享相同的方法定义

```python
class Person:
	def __init__(self, name, age):
		self.name = name
		self.age = age
	def introduce(self):
		print(f"My name is {self.name} and I 			am {self.age} years old.")
person1 = Person("Alice", 25)
person2 = Person("Bob", 30)
```

实例说明：

1、实例有自己的作用域和名字空间,可以为该实例添加实例变量（也叫属性)
2、实例可以调用类方法和实例方法
3、实例可以访问类变量和实例变量

#### self

类实例化后，self即代表着实例（对象）本身

我们可以把self理解为实例对象的身份证

类比人类，人类就是一个Python类，每个个体的人代表着实例（对象），而每个人的身份证代表的Python中self，每个人可以凭借身份证去上大学、坐高铁、住酒店...（方法），而Python中的实例（对象）也可以凭着self去调用类的方法。

说明：

1、self 是类方法的第一个参数，用于引用对象本身。

2、self 不是Python关键字，但是约定俗成的命名，可以使用其他名称代替，但通常不建议

```python
class Students:
# 构造方法
	def __init__(self,name):
		self.name = name
# 实例方法
	def study(self,examination_results):
		self.examination_results = 							examination_results
		print("同学{}的考试分数是	{}".format(self.name,self.examination_results))
		print("该实例对象的地址是{}".format(self)
```

打印self出现下面对象信息
<main.Students object at 0x00000129EB0F6B38>
<main.Students object at 0x00000129EB0F6B00>

#### 属性和方法

##### 属性：

每个实例可以有自己的变量，称为实例变量(也叫属性)

语法：

```python
实例.属性名
```

属性的赋值规则：
1、首次为属性赋值则创建此属性.
2、再次为属性赋值则改变属性的绑定关系

作用：

记录每个对象自身的数据

示例：

```python
class Dog:
	def eat(self, food):
		print(self.color, '的', self.kinds, '正在吃', food)
	pass
# 创建一个实例：
dog1 = Dog()
dog1.kinds = "京巴" # 添加属性
dog1.color = "白色"
dog1.color = "黄色" # 改变属性的绑定关系
print(dog1.color, '的', dog1.kinds)
dog2 = Dog()
dog2.kinds = "藏獒"
dog2.color = "棕色"
print(dog2.color, '的', dog2.kinds)
```

##### 方法：

```python
class 类名(继承列表):
	def 实例方法名(self, 参数1, 参数2, ...):
		"文档字符串"
		语句块
```

实例方法的作用：用于描述一个对象的行为,让此类型的全部对象都拥有相同的行为

说明：

1、实例方法的实质是函数，是定义在类内的函数
2、实例方法至少有一个形参，第一个形参绑定调用这个方法的实例,一般命名为"self"
3、实例方法名是类属性

调用语法：

```python
实例.实例方法名(调用传参)
# 或
类名.实例方法名(实例, 调用传参)
```

##### 类属性

类属性是类的属性，此属性属于类，不属于此类的实例

作用：通常用来存储该类创建的对象的共有属性

说明：

1、类属性,可以通过该类直接访问

2、类属性,可以通过类的实例直接访问

##### 类方法

类方法是用于描述类的行为的方法，类方法属于类，不属于该类创建的对象
说明
1、类方法需要使用@classmethod装饰器定义
2、类方法至少有一个形参，第一个形参用于绑定类，约定写为'cls'
3、类和该类的实例都可以调用类方法
4、类方法不能访问此类创建的对象的实例属性

##### cls

在Python中， cls 是一个约定俗成的名称，用于表示类本身。在类方法（使用 @classmethod 装饰的方法）中， cls 作为第一个参数传递给方法。这使得类方法可以访问和修改类属性以及调用其他类方法，而不需要引用具体的实例。
cls 的作用：

1. 访问类属性：类方法可以通过 cls 访问和修改类属性。
2. 调用类方法：类方法可以通过 cls 调用其他类方法。
3. 创建类实例：类方法可以使用 cls 来创建类的实例。

##### 静态方法@staticmethod

静态方法是定义在类的内部函数，此函数的作用域是类的内部
说明：
1、静态方法需要使用@staticmethod装饰器定义
2、静态方法与普通函数定义相同，不需要传入self实例参数和cls类参数
3、静态方法只能凭借该类或类创建的实例调用
4、静态方法能访问类属性但不能访问实例属性

##### 初始化方法

初始化方法的作用：对新创建的对象添加属性

语法：

```python
class 类名(继承列表):
	def __init__(self[, 形参列表]):
		语句块
# [] 代表其中的内容可省略
```

初始化方法的说明：
1、初始化方法名必须为 \__init\__ 不可改变
2、初始化方法会在构造函数创建实例后自动调用,且将实例自身通过第一个参数self传入\__init\__ 方法
3、构造函数的实参将通过 \__init\__ 方法的参数列表传入到 \__init\__ 方法中
4、初始化方法内如果需要return语句返回，则必须返回None

##### 魔术方法

魔术方法（Magic Methods）是一种特殊的方法，它们以双下划线开头和结尾，例如__init__ ， __str__ ， __add__ 等。这些方法允许您自定义类的行为，以便与内置Python功能（如+运算符、迭代、字符串表示等）交互。

#### 继承/派生

继承是从已有的类中派生出新的类，新类具有原类的数据属性和行为，并能扩展新的能力。派生类就是从一个已有类中衍生出新类，在新的类上可以添加新的属性和行为

为什么继承/派生

1、继承的目的是延续旧的类的功能
2、派生的目地是在旧类的基础上添加新的功能

继承/派生的作用

1、用继承派生机制，可以将一些共有功能加在基类中。实现代码的共享。
2、在不改变基类的代码的基础上改变原有类的功能

##### 单继承

语法：

```python
class 类名(基类名):
	语句块
```

单继承是指派生类由一个基类衍生出来的

##### 多继承

语法：

```python
class DerivedClassName(Base1, Base2, Base3):
	<statement-1>
	.
	.
	.
	<statement-N>
```

需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索即方法在子类中未找到时，从左到右查找父类中是否包含方法

##### 覆盖override

覆盖是指在有继承关系的类中，子类中实现了与基类同名的方法,在子类的实例调用该方法时，实际调用的是子类中的覆盖版本,这种现象叫覆盖。

作用：实现和父类同名，但功能不同的方法

#### 封装enclosure

封装是指隐藏类的实现细节，让使用者不用关心这些细节;
封装的目的是让使用者通过尽可能少的方法(或属性)操作对象。Python的封装是假的（模拟的）封装
私有属性和方法：

python类中以双下划线( __ )开头，不以双下划线结尾的标识符为私有成员,私有成员只能使用方法来进行访问和修改
1、以 __ 开头的属性为类的私有属性，在子类和类外部无法直接使用
2、以 __ 开头的方法为私有方法，在子类和类外部无法直接调用

#### 多态polymorphic

多态是指在有继承/派生关系的类中，调用基类对象的方法,实际能调用子类的覆盖方法的现象

说明：

1、多态调用的方法与对象相关，不与类型相关
2、Python的全部对象都只有"运行时状态(动态)", 没有"C++语言"里的"编译时状态(静态)

# day5

## 方法重写

父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法

### 函数重写

在自定义类内添加相应的方法,让自定义类创建的实例像内建对象一样进行内建函数操作

#### 对象转字符串函数重写

```python
class MyNumber:
"此类用于定义一个自定义的类，用于演示str/repr函数重写"
	def __init__(self, value):
	"构造函数,初始化MyNumber对象"
		self.data = value
	def __str__(self):
	"转换为普通字符串"
		return "%s" % self.data
n1 = MyNumber("一只猫")
n2 = MyNumber("一只狗")
print("str(n2) ===>", str(n2))
```



#### 内建函数重写

```python
class MyList:
	def __init__(self, iterable=()):
		self.data = [x for x in iterable]
	def __repr_(self):
		return "MyList(%s)" % self.data
	def __len__(self):
		print("__len__(self) 被调用!")
		return len(self.data)
	def __abs__(self):
		print("__len__(self) 被调用!")
		return MyList((abs(x) for x in self.data))
myl = MyList([1, -2, 3, -4])
print(len(myl))
print(abs(myl))
```



### 运算符重载

运算符重载是指让自定义的类生成的对象(实例)能够使用运算符进行操作
运算符重载的作用：
1、让自定义类的实例像内建对象一样进行运算符操作
2、让程序简洁易读
3、对自定义对象将运算符赋予新的运算规则
运算符重载说明：运算符重载方法的参数已经有固定的含义,不建议改变原有的意义

#### 算术运算符重载

```python
def __xxx__(self, other):
	....
```

示例：

```python
class MyNumber:
"此类用于定义一个自定义的类，用于演示运算符重载"
	def __init__(self, value):
	"构造函数,初始化MyNumber对象"
		self.data = value
	def __str__(self):
	"转换为表达式字符串"
		return "MyNumber(%d)" % self.data
	def __add__(self, rhs):
	"加号运算符重载"
		print("__add__ is called")
		return MyNumber(self.data + rhs.data)
	def __sub__(self, rhs):
	"减号运算符重载"
		print("__sub__ is called")
		return MyNumber(self.data - rhs.data)
n1 = MyNumber(100)
n2 = MyNumber(200)
print(n1 + n2)
print(n1 - n2)
```



## super函数

super() 函数是用于调用父类(超类)的一个方法。

super() 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。
super() 方法的语法:
1、在子类方法中可以使用super().add()调用父类中已被覆盖的方法
2、可以使用super(Child, obj).myMethod()用子类对象调用父类已被覆盖的方法



super().__init__() 是 Python 中用于调用父类（基类）构造函数的一种方式。它通常用于子类的构造函数中，以确保父类的构造函数被正确调用和初始化。这在继承（inheritance）中尤为重要，因为父类的初始化代码可能包含设置实例变量或执行其他重要的初始化任务

## python迭代器和生成器

### 迭代器

什么是迭代器：

1、迭代器是访问可迭代对象的工具
2、迭代器是指用 iter(obj) 函数返回的对象(实例)
3、迭代器可以用next(it)函数获取可迭代对象的数据

迭代器函数iter和next

| 函数           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| iter(iterable) | 从可迭代对象中返回一个迭代器,iterable必须是能提供一个迭代器的对象 |
| next(iterator) | 从迭代器iterator中获取下一个记录，如果无法获取一下条记录，则触发<br/>StopIteration 异常 |

说明：

1、迭代器只能往前取值,不会后退
2、用iter函数可以返回一个可迭代对象的迭代器

### 生成器

生成器是在程序运行时生成数据，与容器不同，它通常不会在内存中保留大量的数据，而是现用现生成。
1、yield 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。
2、跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。
3、每次使用 yield 语句生产一个值后，函数都将暂停执行，等待被重新唤醒。
4、yield 语句相比于 return 语句，差别就在于 yield 语句返回的是可迭代对象，而 return 返回的为不可迭代对象。
5、然后，每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。

生成器有两种
1. 生成器函数
2. 生成器表达式

##### 生成器函数

含有yield 语句的函数是生成器函数，此函数调用回返回一个生成器对象，生成器也是可迭代对象

yield 语句的语法

```python
yield 表达式
```

##### 生成器表达式

语法：

```python
( 表达式 for 变量 in 可迭代对象 [if 真值表达式])
```

作用：用推导式的形式创建一个生成器

示例：

```python
>>> [x ** 2 for x in range(1, 5)] # 列表解析(列表推导式)
[1, 4, 9, 16]
>>>
>>> (x ** 2 for x in range(1, 5)) # 生成器表达式
<generator object <genexpr> at 0x7f41dcd30a40>
>>> for y in (x ** 2 for x in range(1, 5)):
... print(y)
```



## python函数式编程

定义：用一系列函数解决问题。
1、函数可以赋值给变量，赋值后变量绑定函数。
2、允许将函数作为参数传入另一个函数。
3、允许函数返回一个函数。

### 函数作为参数

将核心逻辑传入方法体，使该方法的适用性更广。

示例：

```python
def func01():
	print("func01执行")
# a = func01
# # print(a)
# a()
def func02():
	print("func02执行")
# 通用
def func03(func):
	print("func03执行")
	func()
func03(func02)
func03(func01)
```

#### 内置高阶函数

定义：将函数作为参数或返回值的函数。

常用：
（1）map(函数，可迭代对象)使用可迭代对象中的每个元素调用函数，将返回值作为新可迭代对象元素；返回值为新可迭代对象。
（2）filter(函数，可迭代对象)，根据条件筛选可迭代对象中的元素，返回值为新可迭代对象。
（3）sorted(可迭代对象, key=函数, reverse=True)排序，返回值为排序后的列表结果。
（4）max(可迭代对象, key = 函数)，根据函数获取可迭代对象的最大值。
（5）min(可迭代对象，key = 函数)，根据函数获取可迭代对象的最小值。

```python
"""
    内置高阶函数
        这个函数的参数或者返回值
"""

class Girl:
    def __init__(self, name="", face_score=0, age=0, height=0):
        self.name = name
        self.face_score = face_score
        self.age = age
        self.height = height

    def __str__(self):
        return "%s-%d-%d-%d" % (self.name, self.face_score, self.age, self.height)


list_girl = [
    Girl("双儿", 96, 22, 166),
    Girl("阿珂", 100, 23, 173),
    Girl("小郡主", 96, 22, 161),
    Girl("方怡", 86, 27, 166),
    Girl("苏荃", 99, 31, 176),
    Girl("建宁", 93, 24, 163),
    Girl("曾柔", 88, 26, 170),
]

# 1. map（） 映射
# 获取美女列表中所有名称
#
# for item in map(lambda i : i.name,list_girl):
#     print(item)

# 2. filter() 过滤器 返回的是符合条件的对象
# 在美女列表中获取颜值>90的美女
for item in filter(lambda i:i.face_score>90,list_girl):
    print(item)

# 3.max/min
# 获得颜值最高的美女
# print(max(list_girl,key=lambda item:item.face_score))
# print(min(list_girl,key=lambda item:item.face_score))

# 4.sorted 排序 注意：没有改变原有的列表，而是返回新的别表
# 升序d
# for item in sorted(list_girl,key=lambda i:i.height):
#     print(item)
# 降序
for item in sorted(list_girl,key=lambda i:i.height,reverse=True):
    print(item)
```

# day6

## 函数作为返回值

### 闭包closure

什么是闭包？

闭包是指引用了此函数外部嵌套函数的变量的函数

闭包就是能够读取其他函数内部变量的函数。只有函数内部的嵌套函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数,同时这个函数又引用了外部的变量“。

在本质上，闭包是将内部嵌套函数和函数外部的执行环境绑定在一起的对象。

**闭包必须满足以下三个条件**

1、必须有一个内嵌函数

2、内嵌函数必须引用外部函数中的变量

3、外部函数返回值必须是内嵌函数

闭包的优缺点：

优点：

1. 逻辑连续，当闭包作为另一个函数调用参数时，避免脱离当前逻辑而单独编写额外逻辑。
2. 方便调用上下文的局部变量。
3. 加强封装性，是第2点的延伸，可以达到对变量的保护作用。

缺点：

1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包
2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭
  包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值

```python
def give_yasuiqian(money):
	def child_buy(obj, m):
		nonlocal money
		if money > m:
		money -= m
		print('买', obj, '花了', m, '元, 剩余', money, '元')
		else:
		print("买", obj, '失败')
	return child_buy
cb = give_yashuqian(1000)
cb('变形金刚', 200)
cb('漫画三国', 100)
cb('手机', 1300)
```



#### 装饰器

装饰器是一个函数，主要作用是用来包装另一个函数或类

作用：在不修改被装饰函数的源代码，不改变被装饰函数的调用方式的情况下添加或改变原函数的功能

语法：

```python
def 装饰器函数名(fn):
	语句块
	return 函数对象
@装饰器函数名 <换行>
def 被装饰函数名(形参列表):
	语句块
```

示例：

```python
def mydeco(func):
    func()
    print("mydeco被调用了")
    def wrapper():
        print("wrapper被调用了")
    return wrapper
@mydeco
def myfun():
	print("函数myfun被调用了")
```

当使用 @mydeco 语法装饰 myfun 函数时，实际上发生的是：
1. myfun 函数作为参数传递给了 mydeco 装饰器。
2. 在 mydeco 内部，首先调用了 func() ，即此时调用了 myfun 函数，产生了输出："函数myfun被调用"。
3. 接着，打印了"装饰器函数被调用了,并返回了wrapper"。
4. 然后， mydeco 装饰器返回了新的函数 wrapper 。
因此，此刻 myfun 实际上被替换成了新的函数 wrapper 。这样的行为正是Python装饰器的特性之一：装饰器可以修改函数的行为，甚至完全替换被装饰的函数。

##### 基本装饰器

有参数的函数装饰器(在myfunc外加了一层)

```python
def mydeco(fn):
	def fx():
		print("====这是myfunc被调用之前====")
		ret = fn()
		print("----这是myfunc被调用之后====")
		return ret
	return fx
@mydeco
def myfunc():
	print("myfunc被调用.")
myfunc()
myfunc()
myfunc()
```



##### 带参数的装饰器

```python
def repeat(num):
	def decorator(func):
		def wrapper(*args, **kwargs):
			for _ in range(num):
			func(*args, **kwargs)
		return wrapper
	return decorator
@repeat(3) # 应用装饰器，重复执行下面的函数3次
def greet(name):
	print(f"Hello, {name}!")
greet("Alice") # 调用被装饰的函数
```



##### 装饰器链

```python
def uppercase(func):
	def wrapper(*args, **kwargs):
		result = func(*args, **kwargs)
		return result.upper()
	return wrapper
def exclamation(func):
	def wrapper(*args, **kwargs):
		result = func(*args, **kwargs)
		return result + "!"
	return wrapper
@exclamation
@uppercase
def say_hello(name):
	return f"Hello, {name}"
greeting = say_hello("Bob")
print(greeting) # 输出 "HELLO, BOB!"
```



##### 类装饰器

```python
class MyDecorator:
	def __init__(self, func):
		self.func = func
	def __call__(self, *args, **kwargs):
		print("Something is happening before the function is called.")
		result = self.func(*args, **kwargs)
		print("Something is happening after the function is called.")
		return result
@MyDecorator # 应用类装饰器
def say_hello(name):
	print(f"Hello, {name}!")
say_hello("Charlie") # 调用被装饰的函数
```

## 包和模块

### 模块

一个.py文件就是一个模块

模块是含有一系列数据、函数、类等的程序

作用：

1、把相关功能的函数等放在一起以利用管理，有利于多人合作开发

模块的分类：

1. 内置模块（在python3 程序内部，可以直接使用）
2. 标准库模块(在python3 安装完后就可以使用的 )
3. 第三方模块（需要下载安装后才能使用）
4. 自定义模块(用户自己编写)

#### 导入模块

语法：

导入一个模块到当前程序

```python
import 模块名 [as 模块新名字]
```

导入一个模块内部的部分属性到当前程序

```python
from 模块名 import 模块属性名 [as 属性新名]
```

导入一个模块内部的全部属性到当前程序

```python
from 模块名 import *
```

- 模块的 `__name__` 属性

  每个.py 模块文件都会有 `__name__` 属性

  1. 当一个模块是最先运行的模块，则这个模块是主模块, 主模块的`__name__` 属性绑定`'__main__'` 字符串

  2. 如果一个模块是用 三种 import 语句中的一个导入的模块，则此模块不是主模块。

     不是主模块的模块的 `__name__` 绑定的 模块名

- **主模块 (`__name__` == `'__main__'`)**： 当一个模块是直接运行的，即不是通过 `import` 语句导入的，那么它的 `__name__` 属性会被赋值为 `'__main__'`。

#### random模块

```
import random
```

| 函数                                | 描述                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| random.choice(seq)                  | 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 |
| random.randrange (start, stop,step) | 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 |
| random.random()                     | 随机生成下一个实数，它在[0,1)范围内。                        |
| random.shuffle(list)                | 将序列的所有元素随机排序,修改原list                          |
| uniform(x, y)                       | 随机生成实数，它在[x,y]范围内.                               |

#### time模块

```python
>>> import time
>>> time.time()   # 返回当前时间的时间戳
1617117219.0382686
>>> time.ctime()    #返回当前的UTC 时间的字符串
'Tue Mar 30 23:14:48 2021'
>>> t1 = time.localtime()   # 返回当前的本地时间元组
>>> t1
time.struct_time(tm_year=2021, tm_mon=3, tm_mday=30, tm_hour=23, tm_min=18, tm_sec=22, tm_wday=1, tm_yday=89, tm_isdst=0)
>>> t1.tm_year
2021
>>> t1.tm_yday
89
>>> time.sleep(3)  # time.sleep(n)  # 让程序睡眠 n 秒
>>> time.strftime("%Y-%m-%d", t1)   # 格式化时间
'2021-03-30'
>>> time.strftime("%y-%m-%d", t1)
'21-03-30'
>>> time.strftime('%Y-%m-%d %H:%M:%S', t1)
'2021-07-21 17:37:41'
    # 用时间元组来创建一个自定义的时间
>>> t2 = time.struct_time ( (2021,1, 1, 10, 11, 20, 0, 0, 0) )
```



#### datetime模块

```python
>>> import datetime
>>> d1 = datetime.datetime.now()  # 返回当前的时间
>>> d1
datetime.datetime(2021, 3, 30, 23, 32, 7, 342559)
>>> d1.year
2021
>>> d1.year, d1.month, d1.day, d1.hour, d1.minute, d1.second, d1.microsecond  # 用 datetime 的各个属性可以得到 具体的信息
(2021, 3, 30, 23, 32, 44, 757673)
>>> d1.strftime("%Y-%m-%d")
'2021-03-30'

## 计算时间差
>>> delta_time = datetime.timedelta(days=2, hours=1)  # 生成 2天1小时后的时间差
>>> delta_time
datetime.timedelta(2, 3600)
>>> t1 = datetime.datetime.now()  # 得到当前时间
>>> t1
datetime.datetime(2021, 3, 30, 23, 39, 26, 863109)
>>> t1 + delta_time  # 计算 未来时间
datetime.datetime(2021, 4, 2, 0, 39, 26, 863109)
```



#### os模块

```python
#1. os.getcwd(): 获取当前工作目录
import os
current_directory = os.getcwd()
print("当前工作目录:", current_directory)

#2. os.chdir(path): 改变当前工作目录
import os
new_directory = "/path/to/new/directory"
os.chdir(new_directory)
print("工作目录已更改为:", os.getcwd())

#3. os.listdir(path='.'): 返回指定目录下的所有文件和目录列表
import os
directory_path = "."
files_and_dirs = os.listdir(directory_path)
print("指定目录下的文件和目录列表:", files_and_dirs)

#4. os.mkdir(path): 创建目录
import os
new_directory = "new_folder"
os.mkdir(new_directory)
print(f"目录 '{new_directory}' 已创建")

#5. os.rmdir(path): 删除目录
import os
directory_to_remove = "new_folder"
os.rmdir(directory_to_remove)
print(f"目录 '{directory_to_remove}' 已删除")

#6. os.remove(path): 删除文件
import os
file_to_remove = "example.txt"
os.remove(file_to_remove)
print(f"文件 '{file_to_remove}' 已删除")
```



### 包

- 包是将模块以文件夹的组织形式进行分组管理的方法，以便更好地组织和管理相关模块。
- 包是一个包含一个特殊的`__init__.py`文件的目录，这个文件可以为空，但必须存在，以标识目录为Python包。
- 包可以包含子包（子目录）和模块，可以使用点表示法来导入。

**作用**

- 将一系列模块进行分类管理,有利于防止命名冲突
- 可以在需要时加载一个或部分模块而不是全部模块

#### 导入包和子包

```python
# 同模块的导入规则
    import 包名 [as 包别名]
    import  包名.模块名 [as 模块新名]
    import  包名.子包名.模块名 [as 模块新名]
    
    from 包名 import 模块名 [as 模块新名]
    from 包名.子包名 import 模块名 [as 模块新名]
    from 包名.子包名.模块名 import 属性名 [as 属性新名]
    
    # 导入包内的所有子包和模块
    from 包名 import *
    from 包名.模块名 import *
```

#### `__init__.py`文件

`__init__.py` 文件的主要作用是用于初始化Python包（package）或模块（module），它可以实现以下功能：

1. **标识包目录：** 告诉Python解释器所在的目录应被视为一个包或包含模块的包。没有这个文件，目录可能不会被正确识别为包，导致无法导入包内的模块。
2. **执行初始化代码：** 可以包含任何Python代码，通常用于执行包的初始化操作，如变量初始化、导入模块、设定包的属性等。这些代码在包被导入时会被执行。
3. **控制包的导入行为：** 通过定义 `__all__` 变量，可以明确指定哪些模块可以被从包中导入，从而限制包的公开接口，防止不需要的模块被导入。
4. **提供包级别的命名空间：** `__init__.py` 中定义的变量和函数可以在包的其他模块中共享，提供了一个包级别的命名空间，允许模块之间共享数据和功能。
5. **批量导入模块：** 可以在 `__init__.py` 文件中批量导入系统模块或其他模块，以便在包被导入时，这些模块可以更方便地使用。

### 第三方包

Python第三方包是由Python社区开发的，可用于扩展Python功能和解决各种问题的软件包。这些包提供了各种各样的功能，包括数据分析、机器学习、网络编程、Web开发、图形处理、自然语言处理等。

1. 使用pip：pip是Python的包管理工具，用于安装、升级和管理第三方包。确保你的Python安装中包含了pip。

2. 安装第三方包：

   - 使用pip安装包：在命令行中运行以下命令来安装包，将"package-name"替换为要安装的包的名称。

     ```python
     pip install package-name
     
     ```

   - 安装特定版本的包：如果你需要安装特定版本的包，可以使用以下命令：

     ```python
     pip install package-name==version
     
     ```

   - 通过镜像安装，可以使用以下命令：

     ```python
     pip install -i https://pypi.tuna.tsinghua.edu.cn/simple package1 package2 package3 ...
     
     ```

   - 从requirements文件安装：你可以将要安装的包及其版本记录在一个文本文件中，通常命名为requirements.txt，然后运行以下命令安装其中列出的所有包：

     ```
     pip install -r requirements.txt
      
     ```

3. 导入包：在Python脚本或交互式环境中，使用`import`语句导入已安装的包，以便在代码中使用它们。

   ```python
   import package_name
   ```

4. 使用包：每个第三方包都有不同的用法和功能，通常伴随着官方文档和示例代码。你可以查阅官方文档，或者使用`help()`函数来了解包的功能和方法。示例：

   ```python
   import package_name
   help(package_name)
   ```

5. 更新和卸载包：

   - 更新包：使用以下命令来更新已安装的包：

     ```python
     pip install --upgrade package-name
     
     ```

   - 卸载包：如果你想卸载包，可以使用以下命令：

     ```python
     pip uninstall package-name
     ```



## 异常

作用:用作信号通知，通知上层调用者有错误产生需要处理

### try语句

语法：

```python
try:
    可能发生异常的语句块
except 错误类型1 [as 变量名1]:
    异常处理语句块1
except 错误类型2 [as 变量名2]:
    异常处理语句块2
...
except 错误类型n [as 变量名n]:
    异常处理语句块n
except:
    异常处理语句块other
else:
    未发生异常的语句
finally:
    最终的处理语句
```

- 作用

  尝试捕获异常，得到异常通知，将程序由异常状态变为正常状态

- 说明

  except 子句可以有 1个或多个

  except: 不给错误类型，可以匹配全部的错误类型

  else 子句里的语句会在 没有错误发生时执行，当处于异常时不执行

  finally 子句里的语句，无论何时都执行

### raise语句

语法：

```
raise 异常类型
或
raise 异常对象
```

作用

- 抛出一个错误，让程序进入异常状态
- 发送错误通知给调用者

```python
## 写一个函数, get_score 函数，读取用户输入的整数成绩,
## 成绩的正常值是0~100 之间， 要求, 如果不在0~100 之间
## 报 ValueError类型的错误
def get_score():
    x = int(input('请输入成绩:'))
    if 0 <= x <= 100:
        return x
    # raise ValueError
    raise ValueError('用户输入的成绩不在 0～100 之间')

try:
    score = get_score()
    print(score)
except ValueError as err:
    print("成绩输入有误 err=", err)
```



### 全部的错误类型

| 错误类型                  | 说明                                               |
| ------------------------- | -------------------------------------------------- |
| ZeroDivisionError         | 除(或取模)零 (所有数据类型)                        |
| ValueError                | 传入无效的参数                                     |
| AssertionError            | 断言语句失败                                       |
| StopIteration             | 迭代器没有更多的值                                 |
| IndexError                | 序列中没有此索引(index)                            |
| IndentationError          | 缩进错误                                           |
| OSError                   | 输入/输出操作失败                                  |
| ImportError               | 导入模块/对象失败                                  |
| NameError                 | 未声明/初始化对象 (没有属性)                       |
| AttributeError            | 对象没有这个属性                                   |
|                           | <!-- 以下不常用 -->                                |
| GeneratorExit             | 生成器(generator)发生异常来通知退出                |
| TypeError                 | 对类型无效的操作                                   |
| KeyboardInterrupt         | 用户中断执行(通常是输入^C)                         |
| OverflowError             | 数值运算超出最大限制                               |
| FloatingPointError        | 浮点计算错误                                       |
| BaseException             | 所有异常的基类                                     |
| SystemExit                | 解释器请求退出                                     |
| Exception                 | 常规错误的基类                                     |
| StandardError             | 所有的内建标准异常的基类                           |
| ArithmeticError           | 所有数值计算错误的基类                             |
| EOFError                  | 没有内建输入,到达EOF 标记                          |
| EnvironmentError          | 操作系统错误的基类                                 |
| WindowsError              | 系统调用失败                                       |
| LookupError               | 无效数据查询的基类                                 |
| KeyError                  | 映射中没有这个键                                   |
| MemoryError               | 内存溢出错误(对于Python 解释器不是致命的)          |
| UnboundLocalError         | 访问未初始化的本地变量                             |
| ReferenceError            | 弱引用(Weak reference)试图访问已经垃圾回收了的对象 |
| RuntimeError              | 一般的运行时错误                                   |
| NotImplementedError       | 尚未实现的方法                                     |
| SyntaxError Python        | 语法错误                                           |
| TabError                  | Tab 和空格混用                                     |
| SystemError               | 一般的解释器系统错误                               |
| UnicodeError              | Unicode 相关的错误                                 |
| UnicodeDecodeError        | Unicode 解码时的错误                               |
| UnicodeEncodeError        | Unicode 编码时错误                                 |
| UnicodeTranslateError     | Unicode 转换时错误                                 |
| 以下为警告类型            |                                                    |
| Warning                   | 警告的基类                                         |
| DeprecationWarning        | 关于被弃用的特征的警告                             |
| FutureWarning             | 关于构造将来语义会有改变的警告                     |
| OverflowWarning           | 旧的关于自动提升为长整型(long)的警告               |
| PendingDeprecationWarning | 关于特性将会被废弃的警告                           |
| RuntimeWarning            | 可疑的运行时行为(runtime behavior)的警告           |
| SyntaxWarning             | 可疑的语法的警告                                   |
| UserWarning               | 用户代码生成的警告                                 |

## 文件操作

文件操作是Python中常见的任务之一，用于创建、读取、写入和管理文件。以下是一些常见的文件操作任务的思路、总结和示例代码：

#### 1. 打开文件

要执行文件操作，首先需要打开文件。使用`open()`函数可以打开文件，指定文件名以及打开模式（读取、写入、追加等）。

```python
# 打开一个文本文件以读取内容
file = open("example.txt", "r")
```

#### 2. 读取文件

一旦文件被打开，可以使用不同的方法来读取文件内容。

```python
# 读取整个文件内容
content = file.read()

# 逐行读取文件内容
for line in file:  #直接遍历文件对象，每次读取一行。这种方式更内存友好，因为不需要将所有行读入内存。
    print(line)
```

```python
with open('example.txt', 'r') as file:
    lines = file.readlines() # 读取文件的所有行，并将其作为一个列表返回。
    for line in lines:
        print(line, end='') 代码和file = open("example.txt", "r")for line in file:
    print(line) 代码的区别
```



#### 3. 写入文件

要写入文件，需要打开文件以写入模式（'w'），然后使用`write()`方法。

```python
# 打开文件以写入内容
file = open("example.txt", "w")

# 写入内容
file.write("这是一个示例文本。")
```

#### 4. 关闭文件

完成文件操作后，应该关闭文件，以释放资源和确保文件的完整性。

```python
file.close()
```

#### 5. 使用with

更安全的方法是使用`with`语句，它会自动关闭文件。

```python
with open("example.txt", "r") as file:
    content = file.read()
    # 文件自动关闭
```

#### 6. 检查是否存在

可以使用`os.path.exists()`来检查文件是否存在。

```python
import os

if os.path.exists("example.txt"):
    print("文件存在")
```

#### 7. 处理异常

在文件操作中，可能会出现各种异常情况，例如文件不存在或没有权限。在文件操作中捕获这些异常是个好习惯。

```python
try:
    with open("example.txt", "r") as file:
        content = file.read()
except FileNotFoundError:
    print("文件不存在")
except Exception as e:
    print(f"发生错误：{e}")
```

#### 8. 复制文件

要复制文件，你可以使用`shutil`模块的`copy`方法。

```python
import shutil

source_file = "source.txt"
destination_file = "destination.txt"

shutil.copy(source_file, destination_file)
```

#### 9. 删除文件

要删除文件，可以使用`os`模块的`remove`方法。

```python
import os

file_to_delete = "file_to_delete.txt"

if os.path.exists(file_to_delete):
    os.remove(file_to_delete)
    print(f"{file_to_delete} 已删除")
else:
    print(f"{file_to_delete} 不存在")
```

#### 10. 修改名称

要改变文件名，可以使用`os`模块的`rename`方法。

```python
import os

old_name = "old_name.txt"
new_name = "new_name.txt"

if os.path.exists(old_name):
    os.rename(old_name, new_name)
    print(f"文件名已更改为 {new_name}")
else:
    print(f"{old_name} 不存在")
```



## Python JSON 数据解析

JSON（JavaScript Object Notation）是一种轻量级数据交换格式，它易于阅读和编写，同时也易于机器解析和生成。Python提供了内置的JSON模块，用于处理JSON数据。

### 1.导入模块

```python
import json
```

### 2. 序列化

```python
import json
data = {
    "name": "John",
    "age": 30,
    "city": "New York"
}

json_str = json.dumps(data)  # json.dumps() 是 Python 的 json 模块中的一个函数，它的作用是将 Python 对象转换为 JSON 格式的字符串。
print(json_str)
```

### 3. 反序列化

```python
json_str = '{"name": "John", "age": 30, "city": "New York"}'

data = json.loads(json_str) # json.loads() 是 Python json 模块中的一个函数，它的作用是将 JSON 格式的字符串转换为 Python 对象。
print(data)
```

### 4. 对象存文件

```python
data = {
    "name": "John",
    "age": 30,
    "city": "New York"
}

with open('data.json', 'w') as json_file:
    json.dump(data, json_file)
```

### 5. 从文件加载

```python
with open('data.json', 'r') as json_file:
    data = json.load(json_file)
    print(data)
```

### 6. 嵌套JSON数据

如果JSON数据包含嵌套结构，您可以使用递归来访

问和修改其中的值。

```python
json_data = {
    "name": "Alice",
    "info": {
        "age": 25,
        "location": "Paris"
    }
}

# 获取嵌套的值
age = json_data["info"]["age"]

# 修改嵌套的值
json_data["info"]["location"] = "New York"

# 将更改后的数据转换为JSON字符串
new_json_str = json.dumps(json_data)
```

### 7. JSON中列表

JSON可以包含列表，可以使用索引来访问列表元素。

```python
json_data = {
    "fruits": ["apple", "banana", "cherry"]
}

# 获取列表中的第一个水果
first_fruit = json_data["fruits"][0]

# 添加一个新水果到列表
json_data["fruits"].append("orange")
```

### 8. JSON中空值

JSON允许表示空值（null），在Python中，它通常转换为`None`。

```python
json_data = {
    "value": None
}
```

**字典和JSON格式不同之处**

1. **数据类型限制**：
   - **JSON**：支持的数据类型包括对象（类似于字典）、数组（类似于列表）、字符串、数字、布尔值和 `null`。JSON 不支持 Python 特有的数据类型如 `tuple`、`set`、`bytes` 等。
   - **Python 字典**：可以包含多种 Python 特有的数据类型，比如 `tuple`、`set`、`bytes` 等。
2. **格式要求**：
   - **JSON**：数据必须以字符串的形式表示，键必须是双引号括起来的字符串，值可以是字符串、数字、布尔值、数组、对象或 `null`。
   - **Python 字典**：键可以是任意不可变的类型（如字符串、数字、元组），值可以是任意类型。键通常用单引号或双引号括起来，但 Python 允许在字典中使用不加引号的键。



## Python正则表达式

正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。re模块使 Python 语言拥有全部的正则表达式功能。正则表达式在网络爬虫、数据分析中有着广泛使用，掌握正则表达式能够达到事半功倍的效果。

|  **模式**   | **描述**                                                     |
| :---------: | :----------------------------------------------------------- |
|      ^      | 匹配字符串的开头                                             |
|      $      | 匹配字符串的末尾。                                           |
|      .      | 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 |
|     […]     | 用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'          |
|    [^…]     | 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。             |
|     re*     | 匹配0个或多个的表达式。                                      |
|     re+     | 匹配1个或多个的表达式。                                      |
|     re?     | 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式         |
|    re{n}    | 匹配n个前面表达式。例如，"o{2}"不能匹配"Bob"中的"o"，但是能匹配"food"中的两个o。 |
|   re{n,}    | 精确匹配n个前面表达式。例如，"o{2,}"不能匹配"Bob"中的"o"，但能匹配"foooood"中的所有o。"o{1,}"等价于"o+"。"o{0,}"则等价于"o\*"。 |
|  re{n, m}   | 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式         |
|     \|      | 匹配a或b                                                     |
|    (re)     | 匹配括号内的表达式，也表示一个组                             |
|   (?imx)    | 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 |
|   (?-imx)   | 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。     |
|   (?: re)   | 类似 (...), 但是不表示一个组                                 |
| (?imx: re)  | 在括号中使用i, m, 或 x 可选标志                              |
| (?-imx: re) | 在括号中不使用i, m, 或 x 可选标志                            |
|   (?#...)   | 注释.                                                        |
|   (?= re)   | 前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 |
|   (?! re)   | 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。 |
|   (?> re)   | 匹配的独立模式，省去回溯。                                   |
|     \w      | 匹配数字字母下划线                                           |
|     \W      | 匹配非数字字母下划线                                         |
|     \s      | 匹配任意空白字符，等价于 [\t\n\r\f]。                        |
|     \S      | 匹配任意非空字符                                             |
|     \d      | 匹配任意数字，等价于 [0-9]。                                 |
|     \D      | 匹配任意非数字                                               |
|     \A      | 匹配字符串开始                                               |
|     \Z      | 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 |
|     \z      | 匹配字符串结束                                               |
|     \G      | 匹配最后匹配完成的位置。                                     |
|     \b      | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |
|     \B      | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |
| \n, \t, 等  | 匹配一个换行符。匹配一个制表符, 等                           |
|   \1...\9   | 匹配第n个分组的内容。                                        |
|     \10     | 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 |



### 1.字符匹配

#### 方法和功能

| **方法**      | **功能**                                                     |
| ------------- | ------------------------------------------------------------ |
| match()       | 判断一个正则表达式是否从开始处匹配一个字符串                 |
| search()      | 遍历字符串，找到正则表达式匹配的第一个位置，返回匹配对象     |
| **findall()** | 遍历字符串，找到正则表达式匹配的所有位置，并以**列表**的形式返回。如果给出的正则表达式中包含子组，就会把子组的内容单独返回，如果有多个子组就会以元组的形式返回。 |
| finditer()    | 遍历字符串，找到正则表达式匹配的所有位置，并以迭代器的形式返回 |

- **hqyj匹配文本中的hqyj**

```python
import re
text="hqyj牛皮6666,hqyj有个老师也牛皮666"
data=re.findall("hqyj",text)
print(data)#['hqyj', 'hqyj']
```

- **[hqyj]匹配h或者q或者y或者j字符**

```python
import re
text="hqyj牛皮6666,hqyj有个老师也牛皮666"
data=re.findall("[hqyj]",text)
print(data)#['h', 'q', 'y', 'j', 'h', 'q', 'y', 'j']
```

```python
import re
text="hqyj牛皮6666,hqyj有个老师也牛皮666"
data=re.findall("[hqyj]牛",text)
print(data)#['j牛']
```

- **[^hqyj]匹配除了hqyj以外的其他字符**

```python
import re
text="hqyj牛皮6666,hqyj有个老师也牛皮666"
data=re.findall("[^hqyj]",text)
print(data)#['牛', '皮', '6', '6', '6', '6', ',', '有', '个', '老', '师', '也', '牛', '皮', '6', '6', '6']

```

- **[a-z]匹配a~z的任意字符([0-9]也可以)**

```python
import re
text="hqyj牛皮6666,hqyj有个老师abchqyj也牛皮666"
data=re.findall("[a-z]hqyj",text)
print(data)#['chqyj']
```

- **.匹配除了换行符以外的任意字符**

```python
import re
text="hqyj牛皮6666,hqyj有个老师abchqyj也牛皮666"
data=re.findall(".hqyj",text)
print(data)#[',hqyj', 'chqyj']
```

```python
import re
text="hqyj牛皮6666,hqyj有个老师abchqyj也牛皮666"
data=re.findall(".+hqyj",text) #贪婪匹配(匹配最长的)
print(data)#['hqyj牛皮6666,hqyj有个老师abchqyj']
```

```python
import re
text="hqyj牛皮6666,hqyj有个老师abchqyj也牛皮666"
data=re.findall(".?hqyj",text)
print(data)#['hqyj', ',hqyj', 'chqyj']
```

### 特殊字符

| **特殊字符** | **含义**                                                     |
| ------------ | ------------------------------------------------------------ |
| \d           | 匹配任何十进制数字；相当于类 [0-9]                           |
| \D           | 与 \d 相反，匹配任何非十进制数字的字符；相当于类 [^0-9]      |
| \s           | 匹配任何空白字符（包含空格、换行符、制表符等）；相当于类 [  \t\n\r\f\v] |
| \S           | 与 \s 相反，匹配任何非空白字符；相当于类 [^  \t\n\r\f\v]     |
| \w           | 匹配任意一个文字字符，包括大小写字母、数字、下划线，等价于表达式[a-zA-Z0-9_] |
| \W           | 于 \w 相反  (注：re.ASCII 标志使得 \w 只能匹配 ASCII 字符)   |
| \b           | 匹配单词的开始或结束                                         |
| \B           | 与 \b 相反                                                   |

- **\w 匹配字母数字下划线(汉字)**

```python
import re
text="华清_远见abc 华清hqyj远见 华清牛皮远见"
data=re.findall("华清\w+远见",text)
print(data)#['华清_远见', '华清hqyj远见', '华清牛皮远见']
```

- **\d匹配数字**

```python
import re
text="hqyj66d6 a1h43d3fd43s43d4 "
data=re.findall("d\d",text) # 只匹配一个数字
print(data)#['d6', 'd3', 'd4', 'd4']
```

```python
import re
text="hqyj66d6 a1h43d3fd43s43d4 "
data=re.findall("d\d+",text)
print(data)#['d6', 'd3', 'd43', 'd4']
```

- **\s匹配任意空白符 包括空格,制表符等等**

```python
import re
text="hqyj666  jack karen 666"
data=re.findall("\sj\w+\s",text)
print(data)#[' jack ']
```



### 2.数量控制

#### *重复0次或者更多次

```python
import re
text="华清远见 华清666远见"
data=re.findall("华清6*远见",text)
print(data)#['华清远见', '华清666远见']
```

#### +重复1次或者更多次

```python
import re
text="华清远见 华清666远见 华清6远见"
data=re.findall("华清6+远见",text)
print(data)#['华清666远见', '华清6远见']
```

#### ?重复1次或者0次

```python
import re
text="华清远见 华清666远见 华清6远见"
data=re.findall("华清6?远见",text)
print(data)#['华清远见', '华清6远见']
```

#### {n}重复n次,n是数字

```python
import re
text="华清远见 华清666远见 华清6远见"
data=re.findall("华清6{3}远见",text)
print(data)#['华清666远见']
```

#### {n,}重复n次或者更多次

```python
import re
text="华清远见 华清666远见 华清6远见 华清66远见"
data=re.findall("华清6{2,}远见",text)
print(data)#['华清666远见', '华清66远见']
```

#### {n,m}重复n到m次

```python
import re
text="华清远见 华清666远见 华清6远见 华清66远见"
data=re.findall("华清6{0,2}远见",text)
print(data)#['华清远见', '华清6远见', '华清66远见']
```



### 3.分组

- **()提取兴趣区域**

```python
import re
text="谢帝谢帝,我要迪士尼,我的电话号码18282832341,qq号码1817696843"
data=re.findall("号码(\d{10,})",text)
print(data)#['18282832341', '1817696843']
```

```python
import re
text="谢帝谢帝,我要迪士尼,我的电话号码18282832341,qq号码1817696843"
data=re.findall("(\w{2}号码(\d{10,}))",text)
print(data)#['18282832341', '1817696843']
```

- **(|)提取兴趣区域(| = or)**

```python
import re
text="第一名张三 第一名物理149分 第一名数学150分 第一名英语148分 第一名总分740分"
data=re.findall("第一名(\w{2,}|\w{2,}\d{2,}分)",text)
print(data)#['张三', '物理149分', '数学150分', '英语148分', '总分740分']
```



### 4.开始和结束

- **^开始**

```python
import re
text = "hqyj66abc hqyj123"
data = re.findall("^hqyj\d+", text)
print(data)  #['hqyj66']
```

- **$结尾**

```python
import re
text = "hqyj66abc hqyj123"
data = re.findall("hqyj\d+$", text)
print(data)  #['hqyj123']
```



### 5.特殊字符

由于正则表达式中* . \  {} () 等等符号具有特殊含义,如果你指定的字符正好就是这些符号,需要用\进行转义

```python
import re
text = "数学中集合的写法是{2}"
data = re.findall("\{2\}", text)
print(data)  #['{2}']
```



### 6.re模块的常用方法

#### re.findall

获取匹配到的所有数据

```python
import re
text="hqyj66d6 a1h43d3fd43s43d4 "
data=re.findall("d\d+",text)
print(data)#['d6', 'd3', 'd43', 'd4']
```



#### re.match

从字符串的起始位置匹配，成功返回一个对象否则返回none。

匹配成功返回对象,对象的方法:

| **方法** | **功能**                               |
| -------- | -------------------------------------- |
| group()  | 返回匹配的字符串                       |
| start()  | 返回匹配的开始位置                     |
| end()    | 返回匹配的结束位置                     |
| span()   | 返回一个元组表示匹配位置（开始，结束） |

```python
import re

# 在起始位置匹配，并返回一个包含匹配 (开始,结束) 的位置的元组
print(re.match('www', "www.python.com").span())#(0, 3)
print(re.match('www', "www.python.com").start())#0
print(re.match('www', "www.python.com").end())#3
# 不在起始位置匹配
print(re.match('com', "www.python.com"))# None
```



#### re.search

扫描整个字符串并返回第一个成功匹配的字符串。成功返回一个对象否则返回none

```python
import re

# 在起始位置匹配 
print(re.search('www', 'www.hqyj.com').span())#(0, 3)
# 不在起始位置匹配
print(re.search('com', 'www.hqyj.com').span())#(9, 12)
```

#### re.sub

替换匹配成功的字符

类似与字符串的replace函数

```python
import re
text = "以前华清远见在四川大学旁边,现在华清远见在西南交大旁边"
data = re.sub("华清远见","北京华清远见科技集团成都中心", text)
print(data)#以前北京华清远见科技集团成都中心在四川大学旁边,现在北京华清远见科技集团成都中心在西南交大旁边

```

#### re.split

根据匹配成功的位置对字符串进行分割

```python
import re
text = "python is   very easy"
data = re.split("\s{1,}", text)
print(data)#['python', 'is', 'very', 'easy']
```

#### re.finditer

类似findall 但是不会全部返回出来 而是返回迭代器(比如匹配成功了10万个  全部返回就很吃内存了)

```python
import re
text = "python is   very easy"
data = re.findall("\w+", text)
print(data)#['python', 'is', 'very', 'easy']
```

```python
import re
text = "python is   very easy"
data = re.finditer("\w+", text)
print(data)
for el in data:
    print(el.group())
```



## 

